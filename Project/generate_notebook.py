import json
import os

notebook_content = {
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Overlapping Genes Benchmark Analysis\n",
    "\n",
    "This notebook contains tools to benchmark the performance and behavior of the overlapping genes simulation.\n",
    "\n",
    "## Benchmarks Included:\n",
    "1.  **Time to Convergence vs Overlap Length**: Measures how scaling the overlap affects runtime.\n",
    "2.  **Convergence Traces**: Plots the energy trajectory of individual runs to verify convergence behavior.\n",
    "3.  **Sequence Diversity**: Analyzes the diversity of generated sequences using Hamming distance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- IMPORTS ---\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import time\n",
    "import os\n",
    "import sys\n",
    "import traceback\n",
    "\n",
    "# Add current directory to path to import overlappingGenes\n",
    "sys.path.append(os.getcwd())\n",
    "import overlappingGenes as og\n",
    "\n",
    "# Set plot style\n",
    "plt.style.use('seaborn-v0_8-whitegrid')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- CONFIGURATION ---\n",
    "\n",
    "# General\n",
    "NUM_TRIALS = 20              # Number of independent trials per condition\n",
    "MAX_ITERATIONS = 100_000_000 # Max steps for convergence check\n",
    "\n",
    "# Benchmark 1: Scaling\n",
    "OVERLAP_LENGTHS = list(range(10, 101, 5)) # Overlaps to test for scaling\n",
    "\n",
    "# Benchmark 2: Traces\n",
    "TRACE_OVERLAP = 60           # Overlap length for trace plotting\n",
    "TRACE_ITERATIONS = 5000      # Number of iterations to plot for traces\n",
    "TRACE_TRIALS = 5             # Number of trials to plot\n",
    "\n",
    "# Benchmark 3: Diversity\n",
    "DIVERSITY_OVERLAPS = [10, 40, 70, 95] # Overlaps to analyze for diversity\n",
    "DIVERSITY_TRIALS = 20        # Number of sequences to generate per overlap\n",
    "\n",
    "# Simulation Parameters\n",
    "T1 = 0.8\n",
    "T2 = 0.93"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- HELPER FUNCTIONS ---\n",
    "\n",
    "def load_dca_params(base_dir, pf_name):\n",
    "    params_file = os.path.join(base_dir, pf_name, f\"{pf_name}_params.dat\")\n",
    "    print(f\"Loading parameters from {params_file}...\")\n",
    "    J, h = og.extract_params(params_file)\n",
    "    return (J, h)\n",
    "\n",
    "def load_natural_energies_stats(base_dir, pf_name):\n",
    "    filename = os.path.join(base_dir, pf_name, f\"{pf_name}_naturalenergies.txt\")\n",
    "    energies = og.load_natural_energies(filename)\n",
    "    return np.mean(energies), np.std(energies)\n",
    "\n",
    "# Load Data Once\n",
    "base_dir = os.getcwd()\n",
    "dca_params_1 = load_dca_params(base_dir, \"PF00004\")\n",
    "dca_params_2 = load_dca_params(base_dir, \"PF00041\")\n",
    "\n",
    "mean_e1, std_e1 = load_natural_energies_stats(base_dir, \"PF00004\")\n",
    "mean_e2, std_e2 = load_natural_energies_stats(base_dir, \"PF00041\")\n",
    "\n",
    "len_h1 = len(dca_params_1[1])\n",
    "len_h2 = len(dca_params_2[1])\n",
    "prot1_len = int(len_h1 / 21)\n",
    "prot2_len = int(len_h2 / 21)\n",
    "\n",
    "print(f\"\\nTarget Ranges: PF00004 [{mean_e1-std_e1:.2f}, {mean_e1+std_e1:.2f}], PF00041 [{mean_e2-std_e2:.2f}, {mean_e2+std_e2:.2f}]\")\n",
    "print(f\"Protein 1 length: {prot1_len}, Protein 2 length: {prot2_len}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Benchmark 1: Time to Convergence vs Overlap Length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "results_overlap = {'x': [], 'time_mean': [], 'time_std': [], 'iter_mean': [], 'iter_std': []}\n",
    "\n",
    "print(f\"Benchmarking Overlap Scaling ({NUM_TRIALS} trials per point)...\")\n",
    "\n",
    "for overlap in OVERLAP_LENGTHS:\n",
    "    times = []\n",
    "    iters = []\n",
    "    print(f\"Testing overlap: {overlap}\", end=\"\")\n",
    "    \n",
    "    for trial in range(NUM_TRIALS):\n",
    "        try:\n",
    "            initial_seq = og.initial_seq_no_stops(prot1_len, prot2_len, overlap, quiet=True)\n",
    "            \n",
    "            start_time = time.perf_counter()\n",
    "            iterations, converged, final_E1, final_E2 = og.overlapped_sequence_generator_convergence(\n",
    "                dca_params_1, dca_params_2, initial_seq, \n",
    "                mean_e1=mean_e1, std_e1=std_e1,\n",
    "                mean_e2=mean_e2, std_e2=std_e2,\n",
    "                max_iterations=MAX_ITERATIONS,\n",
    "                T1=T1, T2=T2\n",
    "            )\n",
    "            end_time = time.perf_counter()\n",
    "            \n",
    "            if converged:\n",
    "                times.append(end_time - start_time)\n",
    "                iters.append(iterations)\n",
    "                print(\".\", end=\"\", flush=True)\n",
    "            else:\n",
    "                print(\"x\", end=\"\", flush=True)\n",
    "                \n",
    "        except Exception as e:\n",
    "            print(f\"!\", end=\"\", flush=True)\n",
    "            continue\n",
    "    \n",
    "    print(f\" Done.\")\n",
    "    \n",
    "    if times:\n",
    "        results_overlap['x'].append(overlap)\n",
    "        results_overlap['time_mean'].append(np.mean(times))\n",
    "        results_overlap['time_std'].append(np.std(times))\n",
    "        results_overlap['iter_mean'].append(np.mean(iters))\n",
    "        results_overlap['iter_std'].append(np.std(iters))\n",
    "\n",
    "print(\"\\nBenchmark Complete.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Plotting Benchmark 1 Results\n",
    "\n",
    "if results_overlap['x']:\n",
    "    x = np.array(results_overlap['x'])\n",
    "    y = np.array(results_overlap['time_mean'])\n",
    "    y_err = np.array(results_overlap['time_std'])\n",
    "    y_safe = np.maximum(y, 1e-9)\n",
    "\n",
    "    fig, axs = plt.subplots(2, 2, figsize=(14, 10))\n",
    "    axs = axs.flatten()\n",
    "\n",
    "    # 1. Linear Time\n",
    "    axs[0].errorbar(x, y, yerr=y_err, fmt='o-', capsize=5, ecolor='red', color='blue')\n",
    "    axs[0].set_title(f'Time to Convergence (Linear)\\n(Trials={NUM_TRIALS})')\n",
    "    axs[0].set_xlabel('Overlap Length (nt)')\n",
    "    axs[0].set_ylabel('Time (s)')\n",
    "\n",
    "    # 2. Log-Log Time\n",
    "    valid_mask = (x > 0) & (y_safe > 0)\n",
    "    if np.any(valid_mask):\n",
    "        axs[1].errorbar(x[valid_mask], y_safe[valid_mask], yerr=y_err[valid_mask], fmt='o-', capsize=5, ecolor='red', color='blue')\n",
    "        axs[1].set_xscale('log')\n",
    "        axs[1].set_yscale('log')\n",
    "        axs[1].set_title(f'Time to Convergence (Log-Log)\\n(Trials={NUM_TRIALS})')\n",
    "        axs[1].set_xlabel('Overlap Length (nt)')\n",
    "        axs[1].set_ylabel('Time (s)')\n",
    "        axs[1].grid(True, which=\"both\", ls=\"-\")\n",
    "\n",
    "    # 3. Iterations (Linear)\n",
    "    axs[2].errorbar(x, results_overlap['iter_mean'], yerr=results_overlap['iter_std'], fmt='o-', capsize=5, ecolor='red', color='green')\n",
    "    axs[2].set_title(f'Iterations to Convergence (Linear)\\n(Trials={NUM_TRIALS})')\n",
    "    axs[2].set_xlabel('Overlap Length (nt)')\n",
    "    axs[2].set_ylabel('Iterations')\n",
    "\n",
    "    # 4. Iterations (Log-Log)\n",
    "    iter_mean = np.array(results_overlap['iter_mean'])\n",
    "    iter_std = np.array(results_overlap['iter_std'])\n",
    "    iter_safe = np.maximum(iter_mean, 1e-9)\n",
    "    \n",
    "    valid_mask_iter = (x > 0) & (iter_safe > 0)\n",
    "    if np.any(valid_mask_iter):\n",
    "        axs[3].errorbar(x[valid_mask_iter], iter_safe[valid_mask_iter], yerr=iter_std[valid_mask_iter], fmt='o-', capsize=5, ecolor='red', color='green')\n",
    "        axs[3].set_xscale('log')\n",
    "        axs[3].set_yscale('log')\n",
    "        axs[3].set_title(f'Iterations to Convergence (Log-Log)\\n(Trials={NUM_TRIALS})')\n",
    "        axs[3].set_xlabel('Overlap Length (nt)')\n",
    "        axs[3].set_ylabel('Iterations')\n",
    "        axs[3].grid(True, which=\"both\", ls=\"-\")\n",
    "\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "else:\n",
    "    print(\"No data to plot.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Benchmark 2: Convergence Traces\n",
    "Visualizing the energy trajectory of individual runs to confirm they settle into the target range."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(f\"Generating convergence traces for Overlap {TRACE_OVERLAP} ({TRACE_TRIALS} trials)...\")\n",
    "\n",
    "fig, axs = plt.subplots(2, 1, figsize=(10, 8), sharex=True)\n",
    "\n",
    "# Plot Thresholds\n",
    "axs[0].axhline(y=mean_e1, linestyle='-', color='gray', alpha=0.5, label='Mean')\n",
    "axs[0].axhline(y=mean_e1 + std_e1, linestyle='--', color='gray', alpha=0.5, label='Mean +/- Std')\n",
    "axs[0].axhline(y=mean_e1 - std_e1, linestyle='--', color='gray', alpha=0.5)\n",
    "\n",
    "axs[1].axhline(y=mean_e2, linestyle='-', color='gray', alpha=0.5)\n",
    "axs[1].axhline(y=mean_e2 + std_e2, linestyle='--', color='gray', alpha=0.5)\n",
    "axs[1].axhline(y=mean_e2 - std_e2, linestyle='--', color='gray', alpha=0.5)\n",
    "\n",
    "for i in range(TRACE_TRIALS):\n",
    "    initial_seq = og.initial_seq_no_stops(prot1_len, prot2_len, TRACE_OVERLAP, quiet=True)\n",
    "    \n",
    "    # Use the _int generator which returns history\n",
    "    # Note: whentosave determines resolution. \n",
    "    # whentosave=0.1 means 1000 saves per run (100/0.1). \n",
    "    # So if we run 5000 iters, we get ~1000 points? No, logic is complex.\n",
    "    # Let's just run it and see.\n",
    "    \n",
    "    final_seq, accepted, hist_e1, hist_e2, final_Es = og.overlapped_sequence_generator_int(\n",
    "        dca_params_1, dca_params_2, initial_seq, \n",
    "        numberofiterations=TRACE_ITERATIONS, \n",
    "        whentosave=0.1, # Save frequently\n",
    "        quiet=True,\n",
    "        T1=T1, T2=T2\n",
    "    )\n",
    "    \n",
    "    # Plot traces\n",
    "    # Create x-axis based on length of history\n",
    "    x_axis = np.linspace(0, TRACE_ITERATIONS, len(hist_e1))\n",
    "    \n",
    "    axs[0].plot(x_axis, hist_e1, alpha=0.7, label=f'Trial {i+1}' if i==0 else \"\")\n",
    "    axs[1].plot(x_axis, hist_e2, alpha=0.7)\n",
    "\n",
    "axs[0].set_ylabel('Energy (Protein 1)')\n",
    "axs[0].set_title(f'Convergence Traces (Overlap {TRACE_OVERLAP}) - Protein 1')\n",
    "axs[0].legend(loc='upper right')\n",
    "\n",
    "axs[1].set_ylabel('Energy (Protein 2)')\n",
    "axs[1].set_title(f'Convergence Traces (Overlap {TRACE_OVERLAP}) - Protein 2')\n",
    "axs[1].set_xlabel('Iterations')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Benchmark 3: Sequence Diversity\n",
    "Analyzing the diversity of generated sequences for different overlap lengths using pairwise Hamming distance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_hamming_distances(sequences):\n",
    "    distances = []\n",
    "    n = len(sequences)\n",
    "    seq_len = len(sequences[0])\n",
    "    for i in range(n):\n",
    "        for j in range(i + 1, n):\n",
    "            # Simple Hamming distance\n",
    "            dist = sum(c1 != c2 for c1, c2 in zip(sequences[i], sequences[j]))\n",
    "            distances.append(dist)\n",
    "    return distances, seq_len\n",
    "\n",
    "fig, axs = plt.subplots(2, 2, figsize=(12, 10))\n",
    "axs = axs.flatten()\n",
    "\n",
    "print(f\"Analyzing Sequence Diversity ({DIVERSITY_TRIALS} trials per overlap)...\")\n",
    "\n",
    "for idx, overlap in enumerate(DIVERSITY_OVERLAPS):\n",
    "    if idx >= 4: break # Limit to 4 plots\n",
    "    \n",
    "    print(f\"  Generating sequences for overlap {overlap}...\")\n",
    "    sequences = []\n",
    "    \n",
    "    for _ in range(DIVERSITY_TRIALS):\n",
    "        initial_seq = og.initial_seq_no_stops(prot1_len, prot2_len, overlap, quiet=True)\n",
    "        # Run until convergence\n",
    "        iters, converged, e1, e2 = og.overlapped_sequence_generator_convergence(\n",
    "            dca_params_1, dca_params_2, initial_seq,\n",
    "            mean_e1=mean_e1, std_e1=std_e1,\n",
    "            mean_e2=mean_e2, std_e2=std_e2,\n",
    "            max_iterations=MAX_ITERATIONS,\n",
    "            T1=T1, T2=T2\n",
    "        )\n",
    "        \n",
    "        # We need the ACTUAL sequence. \n",
    "        # The convergence function returns (iters, converged, E1, E2).\n",
    "        # It DOES NOT return the sequence! We need to modify it or use the _int one.\n",
    "        # Actually, let's use the _int one for a fixed number of steps that we know converges,\n",
    "        # OR we modify the convergence function to return the sequence.\n",
    "        # For now, let's use _int with a high iteration count (e.g. 100k) which usually converges.\n",
    "        \n",
    "        final_seq_str, _, _, _, _ = og.overlapped_sequence_generator_int(\n",
    "             dca_params_1, dca_params_2, initial_seq,\n",
    "             numberofiterations=100000, # Should be enough for most\n",
    "             quiet=True,\n",
    "             T1=T1, T2=T2\n",
    "        )\n",
    "        sequences.append(final_seq_str)\n",
    "\n",
    "    # Calculate distances\n",
    "    dists, seq_len = calculate_hamming_distances(sequences)\n",
    "    \n",
    "    # Plot Histogram\n",
    "    axs[idx].hist(dists, bins=15, color='purple', alpha=0.7)\n",
    "    axs[idx].set_title(f'Overlap {overlap} (Len: {seq_len} nt)')\n",
    "    axs[idx].set_xlabel('Hamming Distance')\n",
    "    axs[idx].set_ylabel('Frequency')\n",
    "    \n",
    "    # Add stats\n",
    "    avg_dist = np.mean(dists)\n",
    "    avg_identity = 100 * (1 - avg_dist / seq_len)\n",
    "    axs[idx].text(0.05, 0.9, f'Avg Dist: {avg_dist:.1f}\\nAvg Identity: {avg_identity:.1f}%', \n",
    "                  transform=axs[idx].transAxes, verticalalignment='top', \n",
    "                  bbox=dict(boxstyle='round', facecolor='white', alpha=0.5))\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "print(\"Diversity Analysis Complete.\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

with open('benchmark_analysis.ipynb', 'w') as f:
    json.dump(notebook_content, f, indent=1)
print("Notebook generated successfully.")
